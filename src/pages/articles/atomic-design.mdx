import { ArticleLayout } from '@/components/ArticleLayout'

export const meta = {
  author: 'Naoki Hirahara',
  date: '2021-07-01',
  title: 'アトミックデザイン / vueのコンポーネント設計 / vuex',
  description:
  'アトミックデザイン / vueのコンポーネント設計 / vuex'
}

export default (props) => <ArticleLayout meta={meta} {...props} />

## アトミックデザイン (Atomic Design) とは

![https://i.gyazo.com/bdf2570be7bbf1e6f21a67ae898dd7c2.jpg](https://i.gyazo.com/bdf2570be7bbf1e6f21a67ae898dd7c2.jpg)

アトミックデザインとは、小さいUIコンポーネントを組み合わせてより大きなコンポーネントを作るUIデザイン手法。

アトミックデザインは5つの段階から構成される。

1. Atoms - UIの最小単位。例：ボタンやラベル、テキスト
2. Molecules - Atomsが組み合わさったもの。例：検索フォーム
3. Organisms - Moleculesが組み合わさり、単一の機能でなく複数の役割を持つ。例：ヘッダー
4. Templates - Organismsが組み合わさったもの。例：ワイヤーフレーム
5. Pages (ページ) - Templatesに画像やテキストが組み合わさったもの

## アトミックデザインのメリット

- コンポーネント設計 - VueやReactと相性が良い
- 統一感・一貫性 - 小さなパーツを組み合わせ、共通部分は再利用する
- 拡張性 - 既存のコンポーネントを組み合わせるか再利用することができる

## アトミックデザインの5つコンポーネント

### 1. Atoms

![https://bradfrost.com/wp-content/uploads/2013/06/atoms.jpg](https://bradfrost.com/wp-content/uploads/2013/06/atoms.jpg)

ラベルやボタンなどUIの最小要素。

HTMLでいう各タグ が1つのAtomsになる。

```jsx
// Atoms
<label></label>
<input />
<button></button>
```

### 2. Molecules

![https://i.gyazo.com/cd235783aba14bf362ebd03f7f968e39.png](https://i.gyazo.com/cd235783aba14bf362ebd03f7f968e39.png)

意味のある単位でAtomsが組み合わさったものがMolecules (例ではフォーム欄) となる。

```html
// Molecules
<form>
  <label></label>
	<input />
	<button>
</form>
```

### 3. Organisms

![https://bradfrost.com/wp-content/uploads/2013/06/organism2.jpg](https://bradfrost.com/wp-content/uploads/2013/06/organism2.jpg)

ロゴやナビのMoleculesが組み合わさり、Organismsとなる。

```html
// Organisms
<header>
	// Molecules
	<h1><img src='logo.png' /></h1>
	// Molecules
	<nav>
		<ul>
			<li>Home</li>
			<li>About</li>
			<li>Blog</li>
			<li>Contact</li>
		</ul>
	</nav>
	// Molecules
	<form>
	  <label></label>
		<input />
		<button>
	</form>
</header>
```

### 4. Templates

![https://bradfrost.com/wp-content/uploads/2013/06/template1.jpg](https://bradfrost.com/wp-content/uploads/2013/06/template1.jpg)

さらにOrganismsが組み合わさりTemplateとなり、枠組みができる。

```html
// Templates
<header>
	...
</header>

<main>
	...
</main>
```

### 5. Pages

![https://bradfrost.com/wp-content/uploads/2013/06/page1.jpg](https://bradfrost.com/wp-content/uploads/2013/06/page1.jpg)

最後にPagesとして具体的な画像や文字のコンテンツを入れ込む。

### 参考

[Atomic Design](https://bradfrost.com/blog/post/atomic-web-design/)

[Atomic Design を分かったつもりになる - DeNA Design](https://design.dena.com/design/atomic-design-%E3%82%92%E5%88%86%E3%81%8B%E3%81%A3%E3%81%9F%E3%81%A4%E3%82%82%E3%82%8A%E3%81%AB%E3%81%AA%E3%82%8B)

[アトミックデザインとは？ コンポーネント単位で創るUIデザイン手法 | Workship MAGAZINE(ワークシップマガジン)](https://goworkship.com/magazine/atomic_design/)

---



## コンポーネントとは

![https://i.stack.imgur.com/WRZip.png](https://i.stack.imgur.com/WRZip.png)

いくつかのパーツを種類別・機能ごとなどにまとめたもの。具体的な定義はなく、割と様々。

1度作成すれば、別なファイルでも容易に再利用可能。

コンポーネントを構成する要素の例

- HTML  -  例：ボタン、フォーム、ラベル
- レイアウト - 例：ヘッダー、サイドバー、フッター
- 状態 - 例：ドロップダウンを表示する/しない
- 機能 - 例：ボタンをクリックしたら外部のAPIにHTTP通信をする

## コンポーネント設計のメリット

- 可読性 - どこに何が書かれているかが分かりやすい
- 再利用性 - 既存のアプリケーションの機能に影響を与えることなく、新しいコンポーネントを追加できる。
- 保守性 - 再利用可能なため、保守が容易。どこにどんなファイルがあるかわかる
- 生産性 - 同じ機能のコンポーネントを再利用し、開発の迅速化

## コンポーネントの単一責任の原則 (責務の分離)

1つのコンポーネントは1つのことに責任もとうよという原則。

要するに、1つのコンポーネントが複数の役割や機能を持つことは、再利用性や拡張性、運用性の面であまり良くないということ。

## どこまで細かいコンポーネントにするべきか

プロジェクトごとによるというのが答え。

コンポーネントには可読性、再利用性、保守性の面によるメリットは大きいが、細かくコンポーネント作りすぎると、返ってファイル数も増えて管理しずらい。

アトミックデザインのデザイン手法でいうとOrganisms以上で作るのがファイル数も多くなりすぎずに良さそう。しかし、複雑な部分はMolecuculesごとAtomsごとにコンポーネントを分けた設計が必要。

### 参考

[コンポーネント](https://v1-jp.vuejs.org/guide/components.html)

[フロントエンドのコンポーネント設計に立ち向かう - Qiita](https://qiita.com/seya/items/8814e905693f00cdade2)

[BASEのVue.jsコンポーネントの設計について登壇してきました - BASEプロダクトチームブログ](https://devblog.thebase.in/entry/2019/11/27/110000)

[Vueを用いた開発プロジェクト用に「コンポーネント設計・実装ガイドライン」を作った話 - Qiita](https://qiita.com/HayatoKamono/items/72b02d439a83d68fc15a)

---

## Vuexとは

VuexはVue.jsアプリケーションのための状態管理パターン + ライブラリのこと。

![https://vuex.vuejs.org/vuex.png](https://vuex.vuejs.org/vuex.png)

ざっくりいうと、グローバル変数としてのstateをVuexが管理してる。

ユーザーの操作によってactionが発生し、mutationsによってstateが変更される。

### Vuexの状態管理の仕組み

1. ユーザーがVue ComponentからVuexで定義したアクションを呼び出す (**Dispatch**)
2. 呼び出したアクションはAPIを通じてサーバー側で何らかの処理をする
3. レスポンスとして返ってきたデータをMutationsへ送る (**Commit**)
4. MutationsがStateを変更する (**Mutate**)
5. StateがVue Coponentsに描画 される (**Render**)

## Vuexをなぜ使うのか？いつ使うのか？

![https://res.cloudinary.com/practicaldev/image/fetch/s--WjTqEV3---/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/wu1dtt6firtg4ln5tn61.png](https://res.cloudinary.com/practicaldev/image/fetch/s--WjTqEV3---/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/wu1dtt6firtg4ln5tn61.png)

**Vuexはコンポーネントを超えて共有される情報を管理する時**に使う。

Vue.jsには、コンポーネントという単位でのデータ管理方法が元々からある。しかし、プロジェクトによっては、特定のコンポーネントだけでなく、複数のコンポーネントでもアクセスしたい情報もある。

そんな時に、Vuexを使うことで、コンポーネントの単位を超え、どのコンポーネントでも同一のデータへアクセスすることができる。

### Vuexを使った最も簡単なカウンターアプリの例

[JSFiddle](https://jsfiddle.net/n9jmu5v7/1269/)

## コアコンセプト

公式のわかりやすいシンプルなコードのみ記載。

### State (状態)

Storeで管理するデータ。

```jsx
// Counter コンポーネントをつくってみましょう
const Counter = {
  template: `<div>{{ count }}</div>`,
  computed: {
    count () {
      return store.state.count
    }
  }
}
```

### Getters (参照)

state内のデータの状態から算出される値 (算出プロパティ)

```jsx
const store = new Vuex.Store({
  state: {
    todos: [
      { id: 1, text: '...', done: true },
      { id: 2, text: '...', done: false }
    ]
  },
  getters: {
    doneTodos: state => {
      return state.todos.filter(todo => todo.done)
    }
  }
})
```

### Mutations (変異)

stateのデータを直接操作するための関数 (同期処理のみ)

```jsx
const store = new Vuex.Store({
  state: {
    count: 1
  },
  mutations: {
    increment (state) {
      // 状態を変更する
      state.count++
    }
  }
})
```

### Actions (行動)

mutationsの操作を各コンポーネントから呼び出すために使用する関数 (非同期処理可)

```jsx
const store = new Vuex.Store({
  state: {
    count: 0
  },
  mutations: {
    increment (state) {
      state.count++
    }
  },
  actions: {
    increment (context) {
      context.commit('increment')
    }
  }
})
```

### Modules (storeの分割)

規模が大きくなるとコードをモジュールとして分割する。

```jsx
const moduleA = {
  state: () => ({ ... }),
  mutations: { ... },
  actions: { ... },
  getters: { ... }
}

const moduleB = {
  state: () => ({ ... }),
  mutations: { ... },
  actions: { ... }
}

const store = new Vuex.Store({
  modules: {
    a: moduleA,
    b: moduleB
  }
})

store.state.a // -> `moduleA` のステート
store.state.b // -> `moduleB` のステート
```

## カウンターアプリの例

[https://i.gyazo.com/d18f73593e107e52b7bac75b06a3d36b.mp4](https://i.gyazo.com/d18f73593e107e52b7bac75b06a3d36b.mp4)

![https://i.gyazo.com/ca5872177a061dacaea0765a0452cb07.png](https://i.gyazo.com/ca5872177a061dacaea0765a0452cb07.png)

![https://i.gyazo.com/f8177bd10d024c66d38b332cdaebf3b4.png](https://i.gyazo.com/f8177bd10d024c66d38b332cdaebf3b4.png)

### 参考

[Vuex とは何か？ | Vuex](https://vuex.vuejs.org/ja/)
