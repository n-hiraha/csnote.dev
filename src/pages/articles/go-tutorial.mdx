import { ArticleLayout } from '@/components/ArticleLayout'

export const meta = {
  author: 'Naoki Hirahara',
  date: '2021-07-01',
  title: 'GOチュートリアル',
  description:
  'GOチュートリアル'
}

export default (props) => <ArticleLayout meta={meta} {...props} />

## Goって？

![https://rooter.jp/wp-content/uploads/2020/01/mWd3laxO_400x400-2.png](https://rooter.jp/wp-content/uploads/2020/01/mWd3laxO_400x400-2.png)

Googleが開発した静的型付け言語。

ブラウザで検索するときは「Golang」と検索するとGo言語の記事がでてくる。

## Goの特徴

- 静的故の厳密さ
- コードがシンプル
- 並列処理が高速
- コンパイル・実行が早い

## 基本型 (組み込みの型)

```go
// 真偽値
bool

// 文字列
string

// 整数
int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

// uint8 の別名
byte

// int32 の別名
// Unicode のコードポイントを表す
rune

// 浮動小数点
float32 float64

// 複素数
complex64 complex128

```

## 変数

- 「var」で定義する。
- 関数内は 「:= 」で省略できる

```go
var n int

var n int = 10

var n = 10 // 型を省略(int型になってる)

var n, j int = 10, 20

var (
	n = 10
	x = 5
)

func main() {
	k := 10 // 関数内ではvarと型も省略できる
	c, python, java := true, false, 'java' // 関数内ではvarと型も省略できる

}
```

## 定数

- 「const」で定義する
- 関数内で「:=」の省略はできない
- iotaを使えば連番を簡単に作れる

```go
const n int

const n int = 10

const (
	Username = "test_user"
	Password = "test_pass"
)

func main() {
	const n = 10 // := の省略はできない
	const s = "banana"
}

const (
	one = iota // 1
	two   // 2
	three // 3
)

```

## 関数

- 引数の型必須
- 返り値の型必須
-

```go
package main

import "fmt"

// 引数と返り値にint型を指定している
func add(x int, y int) int {
	return x + y
}
func main() {
	fmt.Println(add(2, 4))
}

func hello1(mae string) string {
	msg = "hello" + name
	return msg
}

// 名前付きreturn関数
// 関数内で使った変数を返す
func hello2(name string) (msg string) {
	msg = "hello" + name
	return
}

```

## For文

- for文のみ
- while文はない

```go
package main

import "fmt"

func main() {
	sum := 1
	for sum < 1000 {
		sum += sum
	}
	fmt.Println(sum)
}
```

### range

- スライスやマップを反復処理する時に使う

```go
package main

import "fmt"

var
```

## if文

```go
package main

import (
	"fmt"
	"math"
)

func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v < lim {
		return v
	} else {
		fmt.Println('else')
	}
	return lim
}

func main() {
	fmt.Println(
		pow(3, 2, 10),
		pow(3, 3, 20),
	)
}
```

## switch

- 選択されたcaseが実行されると、他のcaseは実行されない

```go
package main

import (
	"fmt"
	"runtime"
)

func main() {
	fmt.Print("Go runs on ")
	switch os := runtime.GOOS; os {
	case "darwin":
		fmt.Println("OS X.")
	case "linux":
		fmt.Println("Linux.")
	default:
		fmt.Printf("%s.\n", os)
	}
}
```

## ポインタ

- 値のメモリアドレスを指す
- &オペレータは、そのオペランドへのポインタを引き出す
- *オペレータは、ポインタのサス先の変数を示す

```go
// &オペレータ
i := 42
p = &i

// *オペレータ
fmt.Println(*p) // ポインタpを通してiから値を読みだす
*p = 21         // ポインタpを通してiへ値を代入する
```

```go
package main

import "fmt"

func main() {
	i, j := 42, 2701

	p := &i;
	fmt.Println(*p) // 42
	*p = 21
	fmt.Println(i) // 21

	p = &j
	*p = *p / 37
	fmt.Println(j) // 73
}
```

### ポインタって？

変数のアドレスを格納している変数。

![https://engineer-club.jp/wp-content/uploads/2018/11/b9fc90cb6683668660a48a64b42cd905-1024x652.jpg](https://engineer-club.jp/wp-content/uploads/2018/11/b9fc90cb6683668660a48a64b42cd905-1024x652.jpg)

## 配列

- 配列は複数の要素を持った値

![https://i.gyazo.com/04de32c2f716e999f1701998ffc10491.png](https://i.gyazo.com/04de32c2f716e999f1701998ffc10491.png)

### 配列の初期化

```go
// ゼロ値で初期化
var n0 [5]int

// 配列リテラルで初期化
var n1 = [3]int{10, 20, 30}

// 要素数を型から推論
n3 := [...]int{1, 2, 3}

// 5番目が50,10番目が100で他が0の要素する11の配列
n4 := [...]int{5: 50, 10: 100}
```

### 配列の操作

```go
n1 := [...]int{10, 20, 30, 40}

// 要素へのアクセス
println(n1[3])

// 配列の長さ 要素数
println(len(n1))

// スライス演算
fmt.Println(ns[1:2])
```

## スライス

![https://i.gyazo.com/e9793ea7b5f246d272f6467cb3585a0f.png](https://i.gyazo.com/e9793ea7b5f246d272f6467cb3585a0f.png)

### スライスの初期化

```go
// ゼロ値はnil
var n1 []int

// 長さと容量を指定して初期化
// 各要素はゼロ値で初期化される
n1 = make([]int, 3, 10)

// スライスリテラルで初期化
// 要素は指定しなくてよい
// 自動で配列はつくられる
var n2 = []int{10, 20, 30, 40}

// 5番目が50、10番目が100でほかが0の要素数11のスライス
n3 := []int{5: 50, 10:100}
```

### スライスの操作

```go
n1 := []int{10, 20, 30, 40, 50}

//　要素へのアクセス
println(n1[2])

// 長さ
println(len(n1))

// 要素の追加
// 容量が足りない場合は背後の配列が再確保される
n1 = append(n1, 60, 70)

// 容量
println(cap(n1))
```

### 配列とスライスの違い

- 配列の要素は固定。スライスは配列への参照。
- 関数に配列を渡すときは配列は値をまるごと渡すため、メモリ的に不効率
    - →goではスライスをよく使う

![https://i.gyazo.com/bdbca179a09bba9e27e9ec554b172538.png](https://i.gyazo.com/bdbca179a09bba9e27e9ec554b172538.png)

[[Golang] 配列とスライスの違い - Qiita](https://qiita.com/tchnkmr/items/10071a53a8bce87b62a3)

## マップ

![https://i.gyazo.com/d9dfa520d8d797feb56fa5c5ddfee482.png](https://i.gyazo.com/d9dfa520d8d797feb56fa5c5ddfee482.png)

### マップの初期化

```go
// ゼロ値はnil
var m map[string]int

// makeで初期化
m = make(map[string]int)

// 容量を指定できる
m = make(map(map[string]int, 10)

// リテラルで初期化
m := map[string]int{"x": 10, "y": 20}

// 空の場合
m := map[string]int{}
```

### マップの操作

```go
m := map[string]int{"x": 10, "y": 20}

// キーを指定してアクセス
println(m["x"])

// キーを指定して入力
m["z"] = 30

// キーを指定して削除
delete(m, "z")

```

## 構造体

![https://i.gyazo.com/dc6dc7f691a5f6c8117e21e4e87e7ac8.png](https://i.gyazo.com/dc6dc7f691a5f6c8117e21e4e87e7ac8.png)

### 構造体リテラル

```go
package main

import "fmt"

type user struct {
// 型リテラル
	id int
	age int
	name string
}{
// フィールドの値
	id 1,
	age 20,
	name "RareTECH"
}
```

## 参考

[A Tour of Go](https://go-tour-jp.appspot.com/list)

[「プログラミング言語Go完全入門」の「完全」公開のお知らせ](https://engineering.mercari.com/blog/entry/goforbeginners/)

[他言語プログラマがgolangの基本を押さえる為のまとめ - Qiita](https://qiita.com/tfrcm/items/e2a3d7ce7ab8868e37f7)いて - pospomeのプログラミング日記](https://www.pospome.work/entry/2020/04/27/153059)